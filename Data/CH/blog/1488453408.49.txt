APUE学习笔记——进程控制1. getpid可以获取进程id。getppid可以获取进程调用进程的id。	2. fork函数：一次调用，两次返回：返回0是在子进程中。返回其他值在父进程中。如果大于0为子进程id；否则失败。	3. 子进程获得了父进程的数据空间（DATA,BSS），堆，栈的副本。进程之间共享正文段。	4. 目前的实现一般不进行全部复制，而实现的是写时复制：及经常只读共享部分，一个进程去更改一块内存是，为这块内存建立一个副本。	5. fork函数产生的子进程会继承父进程的文件描述符。这里我们遇到过一个问题。同时也会继承父进程的资源限制等很多的东西。	6. fork失败，可能经常过多。也可能是进程有了太多的子进程。子进程最大值为CHILD_MAX。	7. 好好研究一下fork，vfork，clone，特别他们的相同之处和差异之处。	8. vfork和fork的区别：vfork之后不会进行复制，它完全使用父进程的地址空间。它的目的是调用这个函数后，马上调用exec。vfork会阻塞父进程，首先运行的子进程，子进程return或者exit后，父进程才允许。在子进程中对变量的修改，都会同步到父进程。他们使用的是同一个空间。如果在调用exec或者exit之前调用依赖于父进程的进一步动作，会导致死锁。	9. 进程终止：exit，_exit,_EXIT（这两个_exit Unix下不清洗缓冲区，由exit调用），main中return， 最后一个线程return，最后一个线程调用thread_exit。异常终止：调用abort，接收某些信号，对最后一个线程取消。	10. 僵尸进程：Unix中，一个已经终止，但是父进程尚未对齐进行善后处理（获取终止进程的有关信息，释放它仍然占有的资源）的进程称之为僵尸进程。	11. 僵尸进程的避免：基本有两种方法：一是在自进程中马上调用fork，这样子进程的子进程会被init进程接管。另外一个方法是使用信用：single（SIGCHLD, SIG_IGN（忽略这个信号即可）），接收这个信号即可。如果要在进程结束后进行一些处理应该如何，如何获取子进程的id？	12. 如果一个进程终止，内核会向进程的父进程发送信号：SIGCHLD。然后父进程可以在信号处理地方调用wait或者waitpid查询进程的终止状态。这两个函数返回的pid的值，入参返回的是种子状态。wait是阻塞式的，会阻塞直到有进程终止。waitpid可以指定要等待的进程的pid，并且可以设置是否阻塞。	13. waittid提供更多的灵活性，wait3和wait4能够获取子进程的资源信息。	14. exec并不创建新进程，进程id前后未变，exec只是用一个全新的程序代替当前进程的正文，数据，堆和栈段。	15. exec执行时不会关闭文件流，除非用fctl设置标志FD_CLOEXEC，但会关闭目录流。	16. system函数调用三个函数：fork，exec，waitpid，它是阻塞式的。设置用户id或者设置组id程序决不允许调用system函数。	17. 会计记录对应于进程而不是程序。其实就是一种经常统计。	18. 进程时间：可以使用times获得三个时间，墙上时间（函数返回），用户时间，系统时间，以及子进程的时间。多进程在调用fork后，函数返回后，父进程和子进程就是在不同的内存空间了，他们彼此无法访问对方的内存了。fork函数在子进程中返回0，在父进程返回小于0则申请子进程失败，大于0表示子进程的pid，成功。