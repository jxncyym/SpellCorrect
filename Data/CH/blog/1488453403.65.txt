APUE学习笔记——信号信号可以自己扩展。 信号产生：1）用户操作：ctl+c；2）硬件异常：除0，内存越界等；3）进程调用kill函数可以将信号发送到另一个进程。4）用户使用kill命令。5）某软件条件产生。 信号处理：   忽略，但是SIGKILL和SIGSTOP不可以忽略，他们向超级用户提供了进程终止或停止的可靠方法。硬件产生异常也不可以忽略。使用SIG_IGN忽略。  捕捉信号，为信号注册一个函数。SIGKILL和SIGSTOP不可以捕捉。（为什么？）  执行系统默认。  信号详细说明： 被中断的系统调用：当捕捉到某个信号时，被中断的是内核中执行的系统调用，而不是函数调用。 若在信号处理程序中处理一个不可重入函数，结果是不可预见的。 使用sigaction可设置SA_NOCLDWAIT标志以避免子进程僵死。 进入信号处理程序后，首先调用signal函数以重新设置此信号的处理程序（在信号被复位回其默认值时，它可能会被丢失，立即重新设置可以减少此窗口时间。） pause函数使调用进程挂起直至捕捉到一个信号。 每个进程都有一个信号屏蔽字，可以设置要阻塞递送到进程的信号。 信号集可以表示多个信号的集合。 sigprocmask:可以设置进程的信号屏蔽字。只为单线程设计。 sigpending可以获得被阻塞而没有递送到进程的信号。 abort（SIGABORT）的意图是在进程终止之前由其执行所需要的清理操作。如果进程捕捉此信号并且调用exit或者_exit，则不会冲洗标准IO缓冲区。 system函数需要忽略SIGINT（CTRL+C）和SIGQUIT，阻塞SIGCHILD。中断信号会发送个包括子进程在内的多个进程。忽略的原因是system可能执行的是交互式命令，会产生中断信号，但是只要子进程处理即可。阻塞SIGCHILD信号时因为system要获取子进程的执行状态，而不是被父进程捕捉导致system不知道执行结果。 忽略信号是指不处理，阻塞是指不上报给进程，但会保存起来（不是一个队列）。 sigsuspend：阻塞，等待任意一个信号后返回。 信号处理过程：进程捕捉到信号进行处理时，进程正在执行的指令序列就被信号处理程序临时中断，它首先处理该信号处理程序中的指令。如果冲信号处理程序中返回，则继续执行捕捉到信号时进程正在执行的指令序列。如果这个时候信号处理程序调用不可冲入函数，结果是不可预测的。对于这个问题好像在那里看到过，可以使用一个文件描述法来主动读取信号并处理。而不是系统自动调用。