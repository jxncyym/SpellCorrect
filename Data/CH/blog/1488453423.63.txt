新手小心：c语言的强符号和弱符号声明：下面的实例全部在linux下尝试，window下未尝试。有兴趣者可以试一下。文章针c初学者。

   c语言的强符号和弱符号是c初学者经常容易犯错的地方。而且很多时候，特别是多人配合开发的程序，它引起的问题往往非常行为怪异而且难以定位。

   什么是强符号和弱符号？

   在c语言中，函数和初始化的全局变量是强符号，未初始化的全局变量时弱符号。强符号和弱符号的定义是连接器用来处理多重定义符号的，它的规则是：

   不允许多个强符号；

   如果一个强符号和一个弱符号，这选择强符号；

   如果多个弱符号，则任意选一个。

   它的陷阱：

   上代码：

   //main.c
#include &lt;stdio.h&gt;
int fun();

int x;

int main()
{
	printf(&quot;in main.c:x=%p\n&quot;, &amp;x);
	fun();
	return 0;
}
//test.c

#include &lt;stdio.h&gt;

int x;

int fun()
{
	printf(&quot;in test.c:x=%p\n&quot;, &amp;x);
	return 0;
}
编译：gcc main.c test.c，运行，结果：in main.c:x=0x80496a8in test.c:x=0x80496a8
   

   两个x是一个变量。这也许可以说的过去，可能一个忘记加extern了。

   再看：

   

   //main.c
#include &lt;stdio.h&gt;
int fun();

int x;

int main()
{
	printf(&quot;in main.c:&amp;x=%p\n&quot;, &amp;x);
	fun();
	return 0;
}
   //test.c

#include &lt;stdio.h&gt;

struct
{
	char a;
	char b;
	char c;
	char d;	
   	int t;
   } x;

int fun()
{
	printf(&quot;in test.c:&amp;x=%p\n&quot;, &amp;x);
	return 0;
}
运行结果：
   

   in main.c:&amp;x=0x80496e0in test.c:&amp;x=0x80496e0

   连接器还认为他们是一个变量，这个时候程序员非常可能认为他们是两个变量（或者说优秀的程序员会）。而事实却相反，同一块内存，在不同的文件中会有不同的类型和含义。这两个文件对这块内存读写的过程中，都会影响到对方，引发非常诡异的问题。

   设想一下，如果是一个程序同时又多个人员来开发，如果他们只有有一个全局变量重名，且没有初始化，那么就会引发问题了。

   在一个程序中出现问题还算好，毕竟代码都在一起。如果你使用的动态库或者静态库中有未初始化的全局变量，并且恰好也和你定义的重名，结果如何？我尝试过，和上面一样，冲突的两个变量地址也相同。而这个时候你如果没有库的源码，当发生了问题，变量被修改，你估计要走很多弯路才能想到是库改了你的变量。这是我曾经解决过的一个问题。从那之后，我要求我们公司所有库的源码中不可以出现非static全局变量。

   如何避免？1、上策：想办法消除全局变量。全局变量会增加程序的耦合性，对他要控制使用。如果能用其他的方法代替最好。

   2、中策：实在没有办法，那就把全局变量定义为static，它是没有强弱之分的。而且不会和其他的全局符号产生冲突。至于其他文件可能对他的访问，可以封装成函数。把一个模块的数据封装起来是一个好的实践。

   3、下策：把所有的符号全部都变成强符号。所有的全局变量都初始化，记住，是所有的。如果一个没有初始化，就可能会和其他人产生冲突，尽管别人初始化了。（自己写代码测试一下）。

   4、必备之策：GCC提供了一个选项，可以检查这类错误：-fno-common。

   c语言为什么设计它？

   容易引发问题，怎么回事C的一个特性？可能是历史的原因，没有深究。但我认为也可能是部分语言设计哲学的原因：c语言的设计哲学有一点就是充分的相信程序员，给他们最大的权利和灵活性。这个特性在某些特殊的情况下也许可能发挥作用。

   语言中的君子和小人：古人说要近君子，远小人。像今天说的这个特性（共同体也可以算一个），应该是c语言中的“小人”（轻拍，可能说的比较重）。我们还是敬而远之的比较好。康熙好像说过，（特殊时期）治国不但要用君子，还要会用小人，但要能够驾驭得当。否则会引火烧身。