并发编程学习总结我看书有个特点，不写笔记，就感觉好像没有看过书，印象不深刻（虽然写了也未必深刻），所以我看书会比较慢，笔记会很多。这里总结一下并发。最近学习《深入理解计算机系统》，最后一章中讲到了并发。之前一直以为并发是为了提高性能，书中将并发理解为逻辑控制流在时间上的重叠。简单的说，就是让机器能够同时处理多个事情，充分利用机器的能力。特别是现在多核机器的普遍，并发可能越来越重要。现代操作系统提供了三种基本的方法用于构造并发：进程，I/O多路复用，线程。我们公司在工作中用的最多的其实是第二种。你也许知道，他是无法利用CPU的多核的。不过还好，我们的服务器上一般会跑多个程序（系统划分为多个程序模块）。某些语言也从语言层面提供了一种并发的机制：协程，比如lua和python，go好像也提供了这种机制。我比较熟悉的是python的协程。1、进程收到客户端的请求后，就申请一个新的进程来处理这个请求。这是利用进程并发的基本模式。“进程有一个清晰的模型：共享文件表，但不共享用户地址空间。”——我实际尝试了一下，准确的说，应该是子进程会继承他生成时父进程打开的文件描述符。当子进程开始运行后，父进程或者子进程在打开的文件描述符将不会被他们共享。被共享的文件描述符是引用计数，所以一般情况下，fork返回后，当父进程和子进程分别执行的时候，他们一般都要各自把不需要的文件描述符关闭掉。linux2.4.22提供了另一种新进程创建函数：clone()系统调用。它允许调用者控制那部分由父子进程共享。优点：独立的地址空间，这样各个进程隔绝，一个进程不会一不小心进入另外一个进程，减少了程序的复杂性，不易出错。缺点：1）进程间共享信息变得困难，需要通过进程间通信（IPC）来解决。2）多个进程要在cpu上进行上下文切换，可能会降低运行速度（如果为了利用多核，进程数目和cpu核数一致则另当别论）。另外IPC也会有开销。2、I/O多路复用这是我们用的比较多的一种方式。之前写过这方面的一篇文章：表驱动法。书中叫做并发事件驱动程序，在事件驱动程序中，逻辑流程一般会被模型化为状态机，当收到一个逻辑流开始请求后，我们就申请一个新的状态机来处理这个请求以及后续的相关请求（状态机我们一般情况下叫做通道）。一个逻辑流的完成往往需要很多的事件，对于后续的事件，我们一般会首先找到时那个状态机在处理它，然后根据事件类型，状态机状态来选择相应的处理函数进行处理，以此推动状态机的前进。优点：1）一个进程可以处理多个逻辑流程；2）它比基于进程的设计给了程序员更多的控制权；3）每个逻辑流都能够访问进程的全部的地址空间，使得流之间共享数据变得更加简单；4）因为没有进程的上下文切换，可能会更加高效。缺点：1）增加了代码的复杂度。事件驱动机制使得对流程的处理被打的七零八散，整个程序只见事件，不见流程——流程隐藏在事件处理的转移和衔接中，降低可读性的同时，也增加了实现的复杂性。2）无法有效的利用多核处理器。3、线程线程的调度和进程的调度一样，都是系统进行调度的，但是线程的切换要比进程快很多。同时，线程之间是对等的，没有父子概念：“主线程和其他线程的区别仅在于它是第一个运行的线程。”“每个线程都有独立的线程上下文，包括线程ID，栈，栈指针，程序计数器，条件码和通用目的寄存器值。每个线程都和其他线程共享进程上下文的其他部分：代码段，数据段，BSS段，堆以及所有共享库代码和数据区域。线程通用共享打开文件的集合”我在开发过程中发现很多人使用线程会遇到两个问题：1）线程没有真正释放。线程释放有两种方式，要么通过pthread_join显示回收，但是这回阻塞主线程。要么分离每个线程，这样，线程结束的时候会自动释放。2）线程安全。这是线程最为人诟病的地方，他会明显的增加程序的复杂性。具体的还是看这篇文章：http://blog.csdn.net/lanphaday/article/details/7218611优点：1）线程的切换比进程要快，而且是操作系统支持的。2）相对进程，更容易在线程间共享信息。3）也能够利用多核的优势。缺点：1）线程会增加程序的复杂度，特别是线程安全问题，需要加倍小心。2）增加线程的同时性能可能会出现下降，因为线程的切换也会有开销。4、协程这个是书上没有，我最近接触的。他也可以提供并发。目前所讨论的协程，一般是编程语言提供支持的。目前我所知提供协程支持的语言包括python，lua，go，据说scala和rust也支持。协程不同于线程的地方在于协程不是操作系统进行切换，而是由程序员编码进行切换的，也就是说切换是由程序员控制的，这样就没有了线程所谓的安全问题。所有的协程都共享整个进程的上下文，这样协程间的交换也非常方便。相对于第二种方案（I/O多路复用），使得使用协程写的程序将更加的直观，而不是将一个完整的流程拆分成多个管理的事件处理。协程的缺点可能是无法利用多核优势，不过，这个可以通过协程+进程的方式来解决。协程可以用来处理并发来提高性能，也可以用来实现状态机来简化编程。我用的更多的是第二个。去年年底接触python，了解到了python的协程概念，后来通过pyconchina2011接触到处理yield，greenlet也是一个协程方案，而且在我看来是更可用的一个方案，特别是用来处理状态机。目前这一块已经基本完成，后面抽时间总结一下。总结一下：1）多进程能够利用多核优势，但是进程间通信比较麻烦，另外，进程数目的增加会使性能下降，进程切换的成本较高。程序流程复杂度相对I/O多路复用要低。2）I/O多路复用是在一个进程内部处理多个逻辑流程，不用进行进程切换，性能较高，另外流程间共享信息简单。但是无法利用多核优势，另外，程序流程被事件处理切割成一个个小块，程序比较复杂，难于理解。3）线程运行在一个进程内部，由操作系统调度，切换成本较低，另外，他们共享进程的虚拟地址空间，线程间共享信息简单。但是线程安全问题导致线程学习曲线陡峭，而且易出错。4）协程有编程语言提供，由程序员控制进行切换，所以没有线程安全问题，可以用来处理状态机，并发请求等。但是无法利用多核优势。上面的四种方案可以配合使用，我比较看好的是进程+协程的模式。