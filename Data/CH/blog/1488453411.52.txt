实际测试下文件IO，有一个感性认识环境（戴尔服务器）：cpu:4核3.1GHZ；内存：4G

   

   1.写文件速度测试结果(测试时间：10S)

   环境：死循环进行写文件，随着循环轮询每个文件，每次循环把内容写入轮到的这个文件


   条件(轮询写文件的个数)

   结果(文件大小总和：单位G)


   1

   1.50


   2

   1.44


   100

   1.39


   500

   1.35


   1000

   1.31


   2000

   1.24


   3000

   1.20


   5000

   1.15

   上面是单线程模式。后面又尝试了一下多线程模式，发现数据差不多，没有什么区别。

   结论：

   1、服务器文件IO速度大概是150M/S。

   2、随着写文件数目的增多，IO速度减少。这里是磁盘寻道时间在影响速度。

   3、单个线程即可使IO达到顶峰。说明CPU处理能够远比IO处理要快。

   

   

   结论：随着读写文件的增多，单位时间内写的速度会降低

   

   

   2.tcp通信recv和send时间比较

   环境：tcp服务器和客户端(非阻塞)，每次发送和接受的缓冲为1000字节


   发包间隔

   send函数执行时间(us)

   recv函数执行时间(us)


   usleep 50000

   9

   10


   usleep 5000

   7

   6


   usleep 0

   1

   2

   

   结论：tcp发包执行时间与udp发包时间差不多，但是收包要比udp慢很多

   

   tcp的recv cpu时间较多。

   

   

   3.udp通信recv和send时间比较

   环境：udp服务器和客户端(非阻塞)，每次发送1000字节，接收为4096字节


   发包间隔

   send函数执行时间(us)

   recv函数执行时间(us)


   usleep 50000

   8

   1


   usleep 25000

   8

   1


   usleep 5000

   8

   1


   usleep 0

   2

   0

   结论：通过上面发现，TCP的发包和UDP在时长上差别不大。但是在收包上要比udp慢。cpu消耗也大。

   

   

   4.写文件时测试fwrite函数执行时间

   执行过程：文件打开后，连续fwrite20次，得到每次调用fwrite的时间

   注意：(用我自己虚拟机测试，戴尔服务器测试过程中没有出现)测试得到的结果有可能会全部时间为0或者部分为0，而且全部测试过程都有概率出现这种情况，


   每次fwrite的字节数

   规律(调用时间较长的是哪几次)


   500

   1，9，17


   1000

   1，5，9，13，17


   2000

   1，3，5，7，9，11，13，15，17，19


   3000

   1，2，3，5，6，7，9，10，11，13，14，16，17，18，20


   4000

   每次调用时间都较长


   5000

   每次调用时间都较长


   6000

   每次调用时间都较长

   

   结论：内核buf：4096，每次发送的数据超过4096时，每次发送调用的时间都较长