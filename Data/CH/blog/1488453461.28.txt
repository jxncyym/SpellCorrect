区分接口继承和实现继承——effective c++学习笔记可以在抽象类中为纯虚函数写一个定义，而编译器不会抱怨。但是只有通过base class::fun来调用。


   过度雷同的函数名会导致class命名空间污染&mdash;&mdash;我已经遇到了这个问题。


   1）
成员函数的接口总是会被继承；


   2）
声明一个pure virtual函数的目的是为了让derived classes只继承函数接口；


   3）
声明简朴的impure virtual函数的目的，是让 derived class继承改函数的接口和实现。


   下面的书里面讲到的一个实例非常值得思考。




   impure virtual会导致继承接口和实现。但是，这样的风险是可能会是程序员忘记重新实现接口。这里有两个办法：


   1、
声明接口为纯虚函数，同时声明一个default的函数，用来作为他的默认实现。默认函数是protected。


   2、
上面的问题是接口和缺省实现没有分开。可以使用纯虚函数，同时加上一个缺省实现来解决这个问题。这样接口和缺省实现就分开了。但是这样又有一个问题，要面临很多的拷贝和粘贴，如果子类很多的话。同时，也失去了对缺省函数的级别限制。我喜欢上面的方案。


   4）
声明简朴的no virtual函数的目的，是让 derived class继承函数的接口以及一份强制实行。


   一个典型的程序有80%的执行时间花费在20%


   请记住：


   1、
接口继承和实现继承不同。在public继承下，derived
classes总是继承base
classes的接口。


   2、
pure virtual函数只具体指定接口继承。


   3、
简朴的impure virtual函数具体指定接口继承和缺省实现继承。


   4、
no-virtual函数具体指定接口继承以及强制性实现继承。