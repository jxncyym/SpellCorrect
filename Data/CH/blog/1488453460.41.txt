绝不重新定义继承而来的no-virtual函数——effective c++学习笔记绝不重新定义继承而来的no-virtual函数（Neverredefineaninheritedno-virtualfunction.）

   如果这样处理，那么这个函数的调用，将取决于指针的类型，而不是对象本身。


   因为no-virtual函数都是静态绑定的（在编译器绑定），而virtual函数是动态绑定（在运行期根据对象来绑定的）。


   这样做违背两个原则：


   1、适用于基类对象的每一件事情，都要适用于其子类。


   2、基类的子类一定要继承no-virtual函数的接口和实现。


   我认为如果发生这种行为，C++编译器应该提示错误。但是C++的设计者如此设计这个特性，可能是有他的考虑（是什么考虑那？更大的灵活性？）。不过这个考虑为程序员多加了很多负担。


   有一个想法，也许可以根据Effective的这55个条款，写一个设计检查工具。通过扫描代码，如果不满足条款，则告警。