APUE学习笔记——线程控制线程属性使用的是结构体ptread_attr_t，它对应用程序是不透明的，这样可以增强程序的可移植性。 可以使用ptread_attr_init进行初始化，使用ptread_attr_destroy进行反初始化（类似于释放操作）。两者必须配对出现。 如果要修改ptread_attr_t，必须调用相应的函数。 如果不关心线程的终止状态，可以将线程设置成分离状态（PTREAD_CRETE_DETACHED，PTREAD_CREATE_JOINABLE）：ptread_attr_setdetachstate，也可以查询线程的分离状态设置：ptread_attr_getdetachstate。 ptread_attr_destroy如果失败将非常难处理。一般需要将线程销毁，否则可能会造成内存泄露。 ptread_attr_getstatck和ptread_attr_setstatck可以获取和设置栈的大小。 如果既想更改栈的默认大小，又不想自己处理，可以使用函数ptread_attr_setstatcksize。 线程属性guardsize可以设置避免栈溢出的 互斥量，读写锁，条件变量也可以设置属性 有些系统函数对线程是不可重入的。操作系统提供了相应的可重入函数，以_r结尾。 线程私有数据：则是一个非常实用的功能，之前我在一个项目中考虑过类似的问题：每个线程需要访问自己私有配置数据（既能区分不同的线程，又有保护自己的数据不被其他线程使用的作用），但是没有想出什么好的方法。现在来看，线程自带的私有数据是一个不错的现成方法：   它的原理是：设置一个全局变量key，然后调用函数创建并对这个key进行初始化。之后每个线程可以malloc一段内存，然后设置线程私有的一些数据，最后调用系统函数和之前key进行关联，这样不用将动态申请的内存指针保存进全局变量中，后面可以通过函数，传入key获取之前设置的内存地址。内存的是否通过创建key时设置的析构函数进行。  key的结构体定义为ptread_key_t，可以使用函数int ptread_key_create(ptread_key_t *keyp, void      (*destructor)(void *))进行设置。  key创建后可以被进程中的所有的线程使用，但是每个线程都可以将key与不同的线程私有数据进行关联。  destructor可以设置key相关联的析构函数。当线程退出时，如果私有数据不为null，析构函数会被调用，入参为私有数据的地址。只有在线程正常退出