APUE学习笔记——线程采用多线程模式可以采用同步编程，而非异步编程，可以简化编程；多个进程间可以很方便的共享数据； 可以通过pthread_self获得自身的线程ID。线程ID只在进程内部唯一。 新创建线程不能保证那个线程先运行，新县城可以访问进程的地址空间，继承线程的浮点环境和信号屏蔽字。 如果任意一个线程调用：exit，_Exit,_exit，进程都会终止。 线程终止方式：1）从启动函数中返回，返回值就是线程的退出码。2）可以被其他线程取消。3）线程调用pthread_exit。 pthread_exit的入参就是现场的退出码。 如果一个线程退出，其他线程就可以使用函数pthread_join来访问到其他线程的退出码。调用这个函数的线程将会一直阻塞，直到指定的线程调用ptread_exit，从主函数中退出，或者被取消。如果被其他的线程取消，rval_ptr指定的内存单元就被设置为PTREAD_CANCELED。 线程的入口函数不要返回局部变量的地址（内存可能已经被回收），可以返回常量的地址（这里错了，应该是返回常量，数字常量地址如何获取？）。（*void）1.或者全局变量的地址。如果是全局变量的话，在多个线程的时候要注意不要有冲突。 ptread_create和ptread_exit无类型指针参数能传递的数字不止一个，可以是更复杂的结构体，但是这个内存必须是调用者完成调用之后必须是有效的。否则会访问非法内存。错误的做法是使用栈中的变量地址返回。正确的方法包括：使用常量；动态申请内存（注意释放内存，不要泄露）；全局变量（注意多个进程间的冲突）； 一个线程可以调用函数ptread_cancel来取消另外一个线程。 可以注册线程取消时的执行函数。可以调用函数ptread_cleanup_push来注册调用函数，注册顺序与执行顺序相反。这些函数将在：1）线程调用ptread_exit函数时；2）响应取消请求时；3）调用函数ptread_cleanup_pop，且产生execute不为0时执行。————如果线程从入口函数中返回而终止，则不会调用清除函数。 分离状态的线程如果被取消，将不可以调用ptread_join等待他的终止状态，会返回失败。 ptread_detach可以是线程处于分离状态。 线程同步：如果变量时只读的，不会产生同步问题。如果一个读，一个写，会有同步问题。 在变量修改时间多于一个存储器访问周期的处理器结构中，当存储器读与存储器写的周期交叉时，会出现不一致的现象。 多线程的原子操作深入分析？ 互斥量：互斥量结构体为ptread_mutex_t，初始化函数是ptread_mutex_init，销毁函数是ptread_mutex_destroy。加锁是ptread_mutex_lock，解锁是ptread_mutex_unlock，尝试加锁而不阻塞（前面那个加锁函数如果没有成功这回阻塞）使用函数ptread_mutex_trylock。 死锁产生：线程对一个锁加锁两次；两个线程各加在两个互斥量上锁，然后在对两外一个线程已经加锁的互斥量加锁。 避免：1）一个线程同时只加一个锁。2）否则的话，加锁之前先释放。3）如果多个锁是有联系的，则对其中一个加锁的时候，必然对多个锁同时加锁。 锁颗粒度太粗，则多个线程要等待相同的锁，源自并发性的改善微乎其微。太细，则流程太过复杂。 读写锁：拥有更高的并行性。多个线程可以同时拥有读模式读写锁，只有一个线程拥有写模式读写锁。 读写锁的相互关系：读加锁时，可以在对其加读锁；写加锁是，不可以加任何锁；如果是读加锁，这个时候写加锁，那么写锁会阻塞，并且期间不可以再加读锁。 初始化和销毁函数：ptread_rwlock_init和ptread_rwlock_destroy。 相关函数：ptread_rwlock_rdlock,ptread_rwlock_wrlock,ptread_rwlock_unlock,ptread_rwlock_tryrdlock,ptread_rwlock_trywrlock。 条件变量：需要和互斥量配合一起使用。知道条件满足才会返回。函数为:ptread_cond系列。