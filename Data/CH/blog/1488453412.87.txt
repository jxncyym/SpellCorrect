APUE学习笔记——进程环境在main中调用exit（1）和reutrn 1是等价的。内核启动一个进程的唯一的方法是调用exec，用户程序终止进程的唯一方法是显示或者隐式的调用_exit或者_EXIT。每个进程都会有一个进程表。进程表是一个全局的指针：environ。extern char **environ可以查看这个环境表。另外，可以通过getenv和putenv来获取修改环境表。写个程序试一下。linux的段：linux正文段从0X08048000单元开始，栈底则从0xC0000000开始栈是向下生长，对向上生长。这里描述的是逻辑地址。编译时，gcc -static可以阻止程序使用动态库，转而使用静态库。malloc: 分配指定字节存储区，值不确定。calloc：原型为void *calloc(size_t nobj, size_t size)，分配size*nobj个字节。realloc：更改以前存储区的长度。原型：void *realloc(void *ptr, size_t new_size);返回值可能还是原来的地址（如果它的后面有足够的存储区），可能发生了更改（后面没有足够的存储区，需要申请一块大的，并且把原先的内容拷贝过去）。new_size是新缓冲区的大小，不是差值。如果ptr为空，则等同于malloc，如果size为0，则等同于free。新申请的东西未初始化。返回的地址一定是对齐的，使其可以存储任何的对象类型。比如，有些系统要求double类型数据的起始地址一定是8的倍数。putenv,setenv,unsetenv三个函数可以更改进程的环境变量。setenv:int setenv(const char *name, const char *value, int rewrite)//rewrite：如果已存在是否覆盖。putenv函数直接将入参放入环境表中，而不分配存储区。这样，如果是栈，则会出错。setjmp和longjmp是全局的goto，不过尽量不要使用，隐含了很多的陷阱，易出错。getrlimit和setrlimit可以修改进程的资源限制。一起时用命令来修改，针对的是所有的进程，这个函数可以针对当前进程。对应的命令式ulimit。

   

   写测试程序验证：

   1、程序死循环，有printf，前台启动和后台启动所占用的CPU是否相同？

2、打开文件，然后关闭文件，说是用的时间是否太大。

还好。平均在50us（0.05毫秒）



3、打开大的文件和打开一个小的文件，占用时间是否相同？差别是否大？

打开模式和打开时间有区别(下面的代码：打开文件，写同样内容)：

a+:20us

w+/w:70us

r:20us

r+:20us



打开一个大文件和打开一个小文件还是有差别的。

一个8M，一个3k,同样适用a+打开，不写内容：

8M：37us

3k: 12us




一个8M，一个3k,同样适用a+打开，写内容（1K）：

8M：60us

3k: 23us


在写一个250M文件，差不多也是60us。和8M差别不大。



改用flush后，写后flush的平均大概在9us。







4、写文件：写相同内容，写到一个空白文件和写到一个大文件中，时间是否相同？



差不多。



5、一个文件，打开，写内容。在进程外删除整个文件，再写文件。看什么效果：能否写成功，文件会不会重新生成，是否会在关闭的时候生成，是否会返回错误从而知道文件不存在了，是否可以通过errno获得这一信息。

目前没有好的方法，写的函数的返回值是成功的，但是文件不存在。目前我的做法是写的时候判断文件是否存在。大约用9us的时间。这比打开在关闭要快很多的。

   6、一个线程顺序的写多个文件和多个线程并行的写多个文件，同样的量，花费的时间是否相同？

   7、文件IO的自带缓存是什么时候写到文件的？是在调用最后的那个write函数？还是在系统内部？如果是前一个，则write调用返回时间是不一样的。